/**
 * Regex-based security vulnerability detector.
 * Runs on already-fetched file content during scans â€” no external dependencies.
 *
 * ~131 rules across 4 severity levels and 10+ languages covering:
 * - Hardcoded secrets & credentials (universal)
 * - Injection (SQL, command, code, NoSQL, XSS, LDAP)
 * - Insecure configuration (CORS, SSL, cookies, headers, CSRF)
 * - Weak cryptography
 * - Information exposure & unsafe deserialization
 * - Prototype pollution, path traversal & open redirect
 * - Production-readiness (debugger, unsafe patterns)
 * - Deprecated / unsafe APIs
 * - Framework-specific issues (Angular, React, Vue, Express, Django)
 *
 * Rules are organized in per-language files under ./rules/
 */

import { ALL_RULES } from './rules/registry';

export type VulnerabilitySeverity = 'critical' | 'high' | 'medium' | 'low';

export interface VulnerabilityFinding {
  id: string;
  severity: VulnerabilitySeverity;
  category: string;
  title: string;
  description: string;
  line: number;
  matchedText: string;
  cwe?: string;
}

export interface VulnerabilityResult {
  total_findings: number;
  critical_count: number;
  high_count: number;
  medium_count: number;
  low_count: number;
  findings: VulnerabilityFinding[];
  scanned: boolean;
}

/**
 * Context passed to a rule's optional validate() callback.
 * Allows multi-line and element-aware inspection after the initial
 * single-line regex matches.
 */
export interface RuleMatchContext {
  /** All lines in the file */
  lines: string[];
  /** 0-based index of the line that matched */
  lineIndex: number;
  /** The RegExp match result */
  match: RegExpMatchArray;
  /** The programming language of the file */
  language: string;
}

export interface VulnerabilityRule {
  id: string;
  severity: VulnerabilitySeverity;
  category: string;
  title: string;
  description: string;
  pattern: RegExp;
  languages: string[] | '*';
  cwe?: string;
  truncateMatch?: boolean;
  commentOnly?: boolean;
  /**
   * When true, this rule is skipped for test/spec/mock files.
   * Useful for production-readiness rules (console, debugger, print)
   * and rules that commonly flag test fixtures (hardcoded passwords, etc.).
   */
  skipTestFiles?: boolean;
  /**
   * Optional post-match validator. Return `false` to suppress a finding
   * that the regex matched but is actually a false positive when
   * considering surrounding context (multi-line tags, element type, etc.).
   */
  validate?: (ctx: RuleMatchContext) => boolean;
}

// Rules are loaded from per-language files via the registry
const RULES = ALL_RULES;

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

const COMMENT_PREFIXES: Record<string, RegExp[]> = {
  JavaScript: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  TypeScript: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  Python: [/^\s*#/],
  Ruby: [/^\s*#/],
  Shell: [/^\s*#/],
  Go: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  Rust: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  Java: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  'C#': [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  'C++': [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  C: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  PHP: [/^\s*\/\//, /^\s*#/, /^\s*\/\*/, /^\s*\*/],
  Swift: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  Kotlin: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  Scala: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  SQL: [/^\s*--/],
  Dart: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  Vue: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/, /^\s*<!--/],
};

function isCommentLine(line: string, language: string): boolean {
  const prefixes = COMMENT_PREFIXES[language];
  if (!prefixes) return false;
  return prefixes.some((p) => p.test(line));
}

function truncateSecret(text: string): string {
  if (text.length <= 8) return '***';
  const show = Math.min(4, Math.floor(text.length / 4));
  return text.slice(0, show) + '***' + text.slice(-show);
}

/**
 * Detects test / spec / mock / fixture / story files based on path patterns.
 * Rules with `skipTestFiles: true` are suppressed for these files.
 */
const TEST_FILE_PATTERNS = [
  /\.(?:test|spec|stories|story)\.[^.]+$/i,
  /\/__tests__\//i,
  /\/test\//i,
  /\/tests\//i,
  /\/fixtures?\//i,
  /\/mocks?\//i,
  /\/e2e\//i,
  /\/cypress\//i,
  /\/playwright\//i,
  /test_[^/]+\.py$/i,
  /[^/]+_test\.(?:py|go)$/i,
  /[^/]+Tests?\.(?:java|cs)$/i,
  /\.setup\.[^.]+$/i,
];

function isTestFile(filePath: string): boolean {
  if (!filePath) return false;
  return TEST_FILE_PATTERNS.some((p) => p.test(filePath));
}

// ---------------------------------------------------------------------------
// Main detector
// ---------------------------------------------------------------------------

export function detectVulnerabilities(
  code: string,
  language: string,
  filePath?: string,
): VulnerabilityResult {
  const findings: VulnerabilityFinding[] = [];
  const lines = code.split('\n');
  const seen = new Set<string>(); // dedup key: ruleId:line
  const testFile = isTestFile(filePath ?? '');

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Skip empty lines
    if (line.trim().length === 0) continue;

    const isComment = isCommentLine(line, language);

    for (const rule of RULES) {
      // Language filter
      if (rule.languages !== '*' && !rule.languages.includes(language)) continue;

      // Skip production-readiness / low-signal rules in test files
      if (rule.skipTestFiles && testFile) continue;

      // Comment-only rules (like VULN-030) only apply to comments
      if (rule.commentOnly) {
        if (!isComment) continue;
      } else {
        // All other rules skip comment-only lines
        if (isComment) continue;
      }

      const match = line.match(rule.pattern);
      if (match) {
        // Run optional context-aware validator to suppress false positives
        if (rule.validate && !rule.validate({ lines, lineIndex: i, match, language })) {
          continue;
        }

        const dedupKey = `${rule.id}:${i + 1}`;
        if (seen.has(dedupKey)) continue;
        seen.add(dedupKey);

        findings.push({
          id: rule.id,
          severity: rule.severity,
          category: rule.category,
          title: rule.title,
          description: rule.description,
          line: i + 1,
          matchedText: rule.truncateMatch
            ? truncateSecret(match[0])
            : match[0].substring(0, 100),
          cwe: rule.cwe,
        });
      }
    }
  }

  return {
    total_findings: findings.length,
    critical_count: findings.filter((f) => f.severity === 'critical').length,
    high_count: findings.filter((f) => f.severity === 'high').length,
    medium_count: findings.filter((f) => f.severity === 'medium').length,
    low_count: findings.filter((f) => f.severity === 'low').length,
    findings,
    scanned: true,
  };
}
