/**
 * Regex-based security vulnerability detector.
 * Runs on already-fetched file content during scans â€” no external dependencies.
 *
 * ~131 rules across 4 severity levels and 10+ languages covering:
 * - Hardcoded secrets & credentials (universal)
 * - Injection (SQL, command, code, NoSQL, XSS, LDAP)
 * - Insecure configuration (CORS, SSL, cookies, headers, CSRF)
 * - Weak cryptography
 * - Information exposure & unsafe deserialization
 * - Prototype pollution, path traversal & open redirect
 * - Production-readiness (debugger, unsafe patterns)
 * - Deprecated / unsafe APIs
 * - Framework-specific issues (Angular, React, Vue, Express, Django)
 *
 * Rules are organized in per-language files under ./rules/
 */

import { ALL_RULES } from './rules/registry';

export type VulnerabilitySeverity = 'critical' | 'high' | 'medium' | 'low';

export interface VulnerabilityFinding {
  id: string;
  severity: VulnerabilitySeverity;
  category: string;
  title: string;
  description: string;
  line: number;
  matchedText: string;
  cwe?: string;
}

export interface VulnerabilityResult {
  total_findings: number;
  critical_count: number;
  high_count: number;
  medium_count: number;
  low_count: number;
  findings: VulnerabilityFinding[];
  scanned: boolean;
}

export interface VulnerabilityRule {
  id: string;
  severity: VulnerabilitySeverity;
  category: string;
  title: string;
  description: string;
  pattern: RegExp;
  languages: string[] | '*';
  cwe?: string;
  truncateMatch?: boolean;
  commentOnly?: boolean;
}

// Rules are loaded from per-language files via the registry
const RULES = ALL_RULES;

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

const COMMENT_PREFIXES: Record<string, RegExp[]> = {
  JavaScript: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  TypeScript: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  Python: [/^\s*#/],
  Ruby: [/^\s*#/],
  Shell: [/^\s*#/],
  Go: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  Rust: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  Java: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  'C#': [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  'C++': [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  C: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  PHP: [/^\s*\/\//, /^\s*#/, /^\s*\/\*/, /^\s*\*/],
  Swift: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  Kotlin: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  Scala: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  SQL: [/^\s*--/],
  Dart: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/],
  Vue: [/^\s*\/\//, /^\s*\/\*/, /^\s*\*/, /^\s*<!--/],
};

function isCommentLine(line: string, language: string): boolean {
  const prefixes = COMMENT_PREFIXES[language];
  if (!prefixes) return false;
  return prefixes.some((p) => p.test(line));
}

function truncateSecret(text: string): string {
  if (text.length <= 8) return '***';
  const show = Math.min(4, Math.floor(text.length / 4));
  return text.slice(0, show) + '***' + text.slice(-show);
}

// ---------------------------------------------------------------------------
// Main detector
// ---------------------------------------------------------------------------

export function detectVulnerabilities(
  code: string,
  language: string,
): VulnerabilityResult {
  const findings: VulnerabilityFinding[] = [];
  const lines = code.split('\n');
  const seen = new Set<string>(); // dedup key: ruleId:line

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Skip empty lines
    if (line.trim().length === 0) continue;

    const isComment = isCommentLine(line, language);

    for (const rule of RULES) {
      // Language filter
      if (rule.languages !== '*' && !rule.languages.includes(language)) continue;

      // Comment-only rules (like VULN-030) only apply to comments
      if (rule.commentOnly) {
        if (!isComment) continue;
      } else {
        // All other rules skip comment-only lines
        if (isComment) continue;
      }

      const match = line.match(rule.pattern);
      if (match) {
        const dedupKey = `${rule.id}:${i + 1}`;
        if (seen.has(dedupKey)) continue;
        seen.add(dedupKey);

        findings.push({
          id: rule.id,
          severity: rule.severity,
          category: rule.category,
          title: rule.title,
          description: rule.description,
          line: i + 1,
          matchedText: rule.truncateMatch
            ? truncateSecret(match[0])
            : match[0].substring(0, 100),
          cwe: rule.cwe,
        });
      }
    }
  }

  return {
    total_findings: findings.length,
    critical_count: findings.filter((f) => f.severity === 'critical').length,
    high_count: findings.filter((f) => f.severity === 'high').length,
    medium_count: findings.filter((f) => f.severity === 'medium').length,
    low_count: findings.filter((f) => f.severity === 'low').length,
    findings,
    scanned: true,
  };
}
